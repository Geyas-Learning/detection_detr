"""
=========================================================
MINIMAL COCO DATASET LOADER (FINAL, FIXED FOR YOUR DATA)
=========================================================

Works with COCO JSON generated by convert_to_coco_json().
Supports:

    - file_name: "images/Class/split/img.jpg"
    - bbox: [xmin, ymin, w, h]
    - category_id
    - width, height

Loads images correctly from:
    img_folder = "data"      # NOT "data/images"
"""

import os
from PIL import Image
import torch
from torch.utils.data import Dataset
from pycocotools.coco import COCO


class CocoDetection(Dataset):
    """
    Minimal fixed COCO loader for DETR evaluation.
    """

    def __init__(self, img_folder, ann_file, transforms=None):
        """
        Args:
            img_folder (str): root path, e.g. "data"
            ann_file (str): full path to coco_val.json
            transforms (callable): usually just ToTensor+Normalize
        """

        self.root = img_folder                # <-- ROOT = "data"
        self.coco = COCO(ann_file)
        self.ids = list(sorted(self.coco.imgs.keys()))
        self.transforms = transforms

    def __len__(self):
        return len(self.ids)

    def __getitem__(self, idx):

        img_id = self.ids[idx]

        # -------------------------------------------------------
        # Load metadata
        # -------------------------------------------------------
        coco_img = self.coco.loadImgs(img_id)[0]

        rel_path = coco_img["file_name"]     # e.g. "images/Smart1/val/x.jpg"
        abs_path = os.path.join(self.root, rel_path)

        if not os.path.exists(abs_path):
            raise FileNotFoundError(f"[COCO] Missing: {abs_path}")

        # -------------------------------------------------------
        # Load image
        # -------------------------------------------------------
        img = Image.open(abs_path).convert("RGB")
        w, h = img.size

        # -------------------------------------------------------
        # Load annotations
        # -------------------------------------------------------
        ann_ids = self.coco.getAnnIds(imgIds=img_id)
        anns = self.coco.loadAnns(ann_ids)

        boxes = []
        labels = []

        for a in anns:
            x, y, bw, bh = a["bbox"]
            boxes.append([x, y, x + bw, y + bh])
            labels.append(a["category_id"])

        if len(boxes) == 0:
            boxes = torch.zeros((0, 4), dtype=torch.float32)
            labels = torch.zeros((0,), dtype=torch.int64)
        else:
            boxes = torch.tensor(boxes, dtype=torch.float32)
            labels = torch.tensor(labels, dtype=torch.int64)

        target = {
            "boxes": boxes,
            "labels": labels,
            "image_id": torch.tensor([img_id]),
            "orig_size": torch.tensor([h, w]),
            "size": torch.tensor([h, w]),
            "height": h,          # needed for postprocessor sizes
            "width": w
        }

        # -------------------------------------------------------
        # Apply transforms (convert to tensor)
        # -------------------------------------------------------
        if self.transforms is not None:
            img, target = self.transforms(img, target)

        return img, target
